package main

import (
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"unicode"

	"github.com/gobuffalo/velvet"
	"github.com/pyros2097/gromer"
	"golang.org/x/mod/modfile"
)

type Route struct {
	Method string
	Path   string
	Pkg    string
}

func getMethod(src string) string {
	if strings.HasSuffix(src, "get.go") {
		return "GET"
	} else if strings.HasSuffix(src, "post.go") {
		return "POST"
	} else if strings.HasSuffix(src, "put.go") {
		return "PUT"
	} else if strings.HasSuffix(src, "patch.go") {
		return "PATCH"
	} else if strings.HasSuffix(src, "delete.go") {
		return "DELETE"
	} else if strings.HasSuffix(src, "head.go") {
		return "HEAD"
	} else if strings.HasSuffix(src, "options.go") {
		return "OPTIONS"
	} else if strings.HasSuffix(src, "connect.go") {
		return "CONNECT"
	} else if strings.HasSuffix(src, "trace.go") {
		return "TRACE"
	} else {
		return ""
	}
}

func getRoute(method, src string) string {
	return strings.ReplaceAll(src, "/"+strings.ToLower(method)+".go", "")
}

func rewritePath(route string) string {
	muxRoute := bytes.NewBuffer(nil)
	foundStart := false
	for _, v := range route {
		if string(v) == "_" && !foundStart {
			foundStart = true
			muxRoute.WriteString("{")
		} else if string(v) == "_" && foundStart {
			foundStart = false
			muxRoute.WriteString("}")
		} else {
			muxRoute.WriteString(string(v))
		}
	}
	return muxRoute.String()
}

func lowerFirst(s string) string {
	for i, v := range s {
		return string(unicode.ToLower(v)) + s[i+1:]
	}
	return ""
}

func main() {
	moduleName := ""
	notFoundPkg := ""
	pkgFlag := flag.String("pkg", "", "specify a package name")
	flag.Parse()
	if pkgFlag == nil || *pkgFlag == "" {
		data, err := ioutil.ReadFile("go.mod")
		if err != nil {
			log.Fatalf("go.mod file not found %s", err.Error())
		}
		modTree, err := modfile.Parse("go.mod", data, nil)
		if err != nil {
			log.Fatalf("could not parse go.mod %s", err.Error())
		}
		moduleName = modTree.Module.Mod.Path
	} else {
		moduleName = *pkgFlag
	}
	err := filepath.Walk("routes",
		func(filesrc string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}
			if !info.IsDir() {
				route := strings.ReplaceAll(filesrc, "routes", "")
				method := getMethod(route)
				if method == "" {
					return nil
				}
				path := getRoute(method, route)
				if path == "" { // for index page
					path = "/"
				}
				data, err := ioutil.ReadFile(filesrc)
				if err != nil {
					return err
				}
				lines := strings.Split(string(data), "\n")
				pkg := strings.Replace(""+lines[0], "package ", "", 1)
				if strings.Contains(filesrc, "/404/") {
					notFoundPkg = pkg
					return nil
				}
				gromer.RouteDefs = append(gromer.RouteDefs, gromer.RouteDefinition{
					Pkg:     pkg,
					PkgPath: getRoute(method, route),
					Method:  method,
					Path:    rewritePath(path),
				})
			}
			return nil
		})
	if err != nil {
		log.Fatal(err)
	}
	sort.Slice(gromer.RouteDefs, func(i, j int) bool {
		return gromer.RouteDefs[i].Path < gromer.RouteDefs[j].Path
	})
	pageRoutes := []gromer.RouteDefinition{}
	apiRoutes := []gromer.RouteDefinition{}
	for _, r := range gromer.RouteDefs {
		fmt.Printf("%-6s %s %-6s\n", r.Method, r.Path, r.PkgPath)
		if strings.Contains(r.Path, "/api/") {
			apiRoutes = append(apiRoutes, r)
		} else {
			pageRoutes = append(pageRoutes, r)
		}
	}
	err = velvet.Helpers.Add("title", func(v string) string {
		return strings.Title(strings.ToLower(v))
	})
	if err != nil {
		log.Fatal(err)
	}
	hasRouteMap := map[string]bool{}
	routeImports := []gromer.RouteDefinition{}
	for _, v := range gromer.RouteDefs {
		if _, ok := hasRouteMap[v.PkgPath]; !ok {
			routeImports = append(routeImports, v)
			hasRouteMap[v.PkgPath] = true
		}
	}
	componentNames := []string{}
	containerNames := []string{}
	for _, p := range []string{"components", "containers"} {
		err = filepath.Walk(p,
			func(filesrc string, info os.FileInfo, err error) error {
				if err != nil {
					return err
				}
				if !info.IsDir() {
					filename := strings.ReplaceAll(filepath.Base(filesrc), ".go", "")
					if p == "containers" {
						containerNames = append(containerNames, strings.Title((filename)))
					} else {
						componentNames = append(componentNames, strings.Title((filename)))
					}
				}
				return nil
			})
		if err != nil {
			log.Fatal(err)
		}
	}
	ctx := velvet.NewContext()
	ctx.Set("moduleName", moduleName)
	ctx.Set("pageRoutes", pageRoutes)
	ctx.Set("apiRoutes", apiRoutes)
	ctx.Set("routeImports", routeImports)
	ctx.Set("componentNames", componentNames)
	ctx.Set("containerNames", containerNames)
	ctx.Set("notFoundPkg", notFoundPkg)
	ctx.Set("tick", "`")
	s, err := velvet.Render(`// Code generated by gromer. DO NOT EDIT.
package main

import (
	"github.com/gorilla/mux"
	"github.com/pyros2097/gromer"
	"github.com/pyros2097/gromer/gsx"
	"github.com/rs/zerolog/log"
	"gocloud.dev/server"

	"{{ moduleName }}/assets"
	"{{ moduleName }}/components"
	"{{ moduleName }}/containers"
	{{#if notFoundPkg}}"{{ moduleName }}/routes/404"{{/if}}
	{{#each routeImports as |route| }}"{{ moduleName }}/routes{{ route.PkgPath }}"
	{{/each}}
)

func init() {
	{{#each componentNames as |name| }}gsx.RegisterComponent(components.{{ name }})
	{{/each}}
	{{#each containerNames as |name| }}gsx.RegisterComponent(containers.{{ name }})
	{{/each}}
	gromer.RegisterAssets(assets.FS)
}

func main() {
	baseRouter := mux.NewRouter()
	baseRouter.Use(gromer.LogMiddleware)
	{{#if notFoundPkg}}
	baseRouter.NotFoundHandler = gromer.StatusHandler({{ notFoundPkg }}.GET)
	{{/if}}
	staticRouter := baseRouter.NewRoute().Subrouter()
	staticRouter.Use(gromer.CacheMiddleware)
	gromer.GromerRoute(staticRouter, "/gromer/")
	gromer.StaticRoute(staticRouter, "/assets/")
	gromer.StylesRoute(staticRouter, "/styles.css")

	pageRouter := baseRouter.NewRoute().Subrouter()
	{{#each pageRoutes as |route| }}gromer.Handle(pageRouter, "{{ route.Method }}", "{{ route.Path }}", {{ route.Pkg }}.{{ route.Method }})
	{{/each}}

	apiRouter := baseRouter.NewRoute().Subrouter()
	apiRouter.Use(gromer.CorsMiddleware)
	{{#each apiRoutes as |route| }}gromer.Handle(apiRouter, "{{ route.Method }}", "{{ route.Path }}", {{ route.Pkg }}.{{ route.Method }})
	{{/each}}
	
	
	log.Info().Msg("http server listening on http://localhost:3000")
	srv := server.New(baseRouter, nil)
	if err := srv.ListenAndServe(":3000"); err != nil {
		log.Fatal().Stack().Err(err).Msg("failed to listen")
	}
}
`, ctx)
	if err != nil {
		panic(err)
	}
	err = ioutil.WriteFile("main.go", []byte(s), 0644)
	if err != nil {
		panic(err)
	}
}
